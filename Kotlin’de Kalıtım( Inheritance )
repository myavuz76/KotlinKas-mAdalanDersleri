Open in app
Sign up

Sign in




Kotlinâ€™de KalÄ±tÄ±m( Inheritance )

Musa soydas

Â·
Follow

3 min read
Â·
Aug 19, 2023

Share

ğŸ‘‹ğŸ» ğŸ‘‹ğŸ» Evett! Tekrardan herkese merhabalar. UmarÄ±m saÄŸlÄ±ÄŸÄ±nÄ±z ve neÅŸeniz iyidir. BugÃ¼n, Kotlin programlama dilinde classâ€™larÄ±n iÃ§inde olan inheritance konusunu paylaÅŸacaÄŸÄ±m. OldukÃ§a heyecanlÄ±yÄ±m, Ã¶yleyse hazÄ±r olduÄŸunuzu dÃ¼ÅŸÃ¼nerek baÅŸlayalÄ±m, deÄŸil mi?

YazÄ±ya baÅŸlamadan Ã¶nce Class konusunda baÅŸlangÄ±Ã§ yaptÄ±ÄŸÄ±m birinci bÃ¶lÃ¼mÃ¼ okumanÄ±zda fayda vardÄ±r. Kotlinde Class YapÄ±sÄ± yazÄ±mÄ± okumak iÃ§in â¤ tÄ±klayÄ±nÄ±z â—€.

Inheritance
Inheritance, bir sÄ±nÄ±fÄ±n baÅŸka bir sÄ±nÄ±ftan Ã¶zelliklerini ve davranÄ±ÅŸlarÄ±nÄ± miras alarak geniÅŸletmesine denir.BaÅŸka bir deyimle de Bir sÄ±nÄ±ftan baÅŸka bir sÄ±nÄ±f tÃ¼retilmesi iÅŸlemine inheritance(kalÄ±tÄ±m) denir. Miras veren sÄ±nÄ±f, â€œÃ¼st sÄ±nÄ±fâ€ veya â€œebeveyn sÄ±nÄ±fâ€ olarak adlandÄ±rÄ±lÄ±rken, miras alan sÄ±nÄ±f â€œalt sÄ±nÄ±fâ€ veya â€œÃ§ocuk sÄ±nÄ±fâ€ olarak anÄ±lÄ±r. Bu mekanizma, kodun tekrarÄ±nÄ± Ã¶nlemeye, hiyerarÅŸiyi oluÅŸturmaya ve kodu daha dÃ¼zenli hale getirmeye yardÄ±mcÄ± olmaktadÄ±r.ğŸ’ªğŸ»ğŸ’ªğŸ»

Åimdi bu Inheritance kotlinde nasÄ±l kullanÄ±lÄ±yor ve nelere dikkat etmemiz gerekiyor hemen bakalÄ±m. Ã–nemli yerleri iÅŸaretlerle beraber sizlere gÃ¶stereceÄŸim.

Inharitance KurallarÄ±,

âœ¨âœ¨Ä°lk olarak kotlin dili kalÄ±tÄ±m almaya kapalÄ±dÄ±r. EÄŸer kalÄ±tÄ±m (inharitance) yapmak istiyorsanÄ±z, yapacaÄŸÄ±nÄ±z classÄ± OPEN keywordÃ¼ kullanÄ±lmalÄ±dÄ±r. AslÄ±nda bi yÃ¶nden de iyidir. Ã‡Ã¼nkÃ¼ eÄŸer classÄ±n baÅŸÄ±nda OPEN keywordÃ¼nÃ¼ gÃ¶rdÃ¼ÄŸÃ¼nÃ¼zde bu class alt sÄ±nÄ±fa kalÄ±tÄ±m vermiÅŸ diyebiliyorsunuz .

class Telephone(){
    /**
     * normal class kullanÄ±mÄ±nda bu ÅŸekilde yazarÄ±z
     */
}
open class Telephone1(){
    /**
     * Miras verecek classÄ±n yazÄ±m ÅŸekli . classÄ±n baÅŸÄ±na open 
     * yazÄ±lmasÄ± zorunludur
     */
}
âœ¨âœ¨KalÄ±tÄ±m verilecek sÄ±nÄ±f , alacak sÄ±nÄ±fÄ± â€œ:â€ sembolÃ¼ ile belirtilmesi gerekmektedir.

open class Telephone() {
    /**
     * Ãœst class
     */

}

class Iphone() : Telephone(){
    /**
     * Miras alacak class
     */
}
âœ¨âœ¨Kodda gÃ¶rdÃ¼ÄŸÃ¼nÃ¼z gibi Iphone ClassÄ± : iÅŸareti sayesinde Telephone classÄ±nÄ± kalÄ±tÄ±m almaktadÄ±r.

â“ Peki Telephone classÄ± constructor alsaydÄ± nasÄ±l olurdu â“

open class Telephone(isCamera: Boolean) {
    /**
     * Ãœst class
     */

}

class Iphone(isCamera: Boolean) : Telephone(isCamera){
    /***
     * Miras alacak class
     */
}
ArtÄ±k Telephone ClassÄ± Camera Ã¶zelliÄŸi olup olmadÄ±ÄŸÄ±nÄ± constructor olarak istiyor. Bundan dolayÄ± artÄ±k miras verdiÄŸi classlarda hata verecek ve bu constructorÄ± isteyecektir. Miras verdiÄŸi classÄ±n constructorÄ±nda da istedik bunu : istedikten sonra aldÄ±ÄŸÄ±mÄ±z deÄŸeri oraya paslÄ±yoruz.

â­â­ï¸ ï¸EÄŸer base sÄ±nÄ±fÄ±n bir parametresi varsa onu kalÄ±tÄ±m alan sÄ±nÄ±f iÅŸlem sÄ±rasÄ±nda base sÄ±nÄ±fa bu parametreyi vermelidir


open class BaseWithSecondaryConstructor() {
    constructor(number: Int) : this()
    constructor(number: Int, age: Int) : this()
}

class DerivedWithSecondaryConstructor : BaseWithSecondaryConstructor {
    constructor(number: Int) : super(number) //super ile yukarÄ±daki base sÄ±nÄ±fÄ±n ConstructorÄ±na eriÅŸilmektedir
    constructor(number: Int, age: Int) : super(number, age)
}
ğŸªğŸª Miras alÄ±nan classÄ±n constructorlarÄ± var ise ( birden fazla olabilmektedir.) Miras vereceÄŸi classta bunlardan bir tanesi kesinlikle yazÄ±lmalÄ±dÄ±r. Yoksa IDE hata verir.

open class Telephone() {
    /**
     * Ãœst class
     */
      open fun makePhoneCall(){
        println("Telephone makePhoneCall() Ã§alÄ±ÅŸtÄ±")
    }
}


class Iphone() : Telephone(){
    /**
     * Miras alacak class
     */
    override fun makePhoneCall() {
        super.makePhoneCall()
        println("Ä°phone makePhoneCall() Ã§alÄ±ÅŸtÄ±")
    }

     fun Airdrop(){
         println("Airdrop fonskiyonu Ã§alÄ±ÅŸtÄ±")  
    }
    
    


}
Telephone classÄ±nda makePhoneCall() fonskiyonu eklendi. Ben bunu artÄ±k kalÄ±tÄ±m yaptÄ±ÄŸÄ±mdan dolayÄ± override ederek bu fonksiyonu Iphone classÄ± kullanabilmektedir. Ancak Iphone classÄ±nda yer alan Airdrop fonksiyonunu ise Telefon classÄ± kullanamaz Ã§Ã¼nkÃ¼ kalÄ±tÄ±m almamaktadÄ±r. Ä°stersen deneyebilirsinâ€¦

override fun makePhoneCall() {
        super.makePhoneCall()
        println("Ä°phone makePhoneCall() Ã§alÄ±ÅŸtÄ±")
    }
buradaki super keywordÃ¼ Ã¼st classtaki fonksiyonuda Ã§aÄŸÄ±rma anlamÄ±na gelmektedir. EÄŸer Ã¼st classtaki fonksiyonun Ã§aÄŸrÄ±lmasÄ±nÄ± istemiyorsanÄ±z bunu silebilirsiniz.

ğŸ’¥ğŸ’¥ KalÄ±tÄ±m alan sÄ±nÄ±fa ait bir fonksiyonun kendisini kalÄ±tÄ±m alan sÄ±nÄ±fta override edilmesini engellemek istiyorsanÄ±z final anahtar kelimesini koymanÄ±z gerekir.Bu durumda bundan sonra kalÄ±tÄ±m alÄ±nan sÄ±nÄ±flara override edilmesini engellenmiÅŸ olmaktadÄ±r.

open class Pen {

    open fun draw() {
        println("pen drawing")
    }
    // open olmadÄ±ÄŸÄ±ndan kalÄ±tÄ±m yapÄ±lamaz
    fun repairPenIfNeeded() {
        println("pen repairing")
    }
    // open olmadÄ±ÄŸÄ±ndan kalÄ±tÄ±m yapÄ±lamaz
    fun changeColor() {
        println("pen change color")
    }
}

open class Pencil : Pen() {

    final override fun draw() {
        super.draw()
        println("pencil drawing")
    }
}

class FaberCastelPencil : Pencil() {
  // ArtÄ±k Ã¼st sÄ±nÄ±fÄ±ndan kalÄ±tÄ±m aldÄ±ÄŸÄ± fonksiyonu kalÄ±tÄ±m alamaz Pencil() classÄ±nda final olarak iÅŸaretlendi   
/* override fun draw() {
        super.draw()
        println("fabercastel drawing")
    }*/ 
}
Kotlinde kalÄ±tÄ±m (inheritance ) ile ilgili yazÄ±mÄ±n sonuna geldik . UmarÄ±m bu kaynak sizler iÃ§in faydalÄ± olur ve yolculuÄŸunuzda size rehberlik eder.

Ä°yi Ã§alÄ±ÅŸmalar dilerimmâ€¦

YazÄ±mÄ± okuduÄŸunuz iÃ§in teÅŸekkÃ¼r ederim! Bir sonra ki yazÄ±larÄ±mda gÃ¶rÃ¼ÅŸmek Ã¼zeree ! Kendinize Ã§ok iyi bakÄ±nnn.

Benimle baÄŸlantÄ± kurmak isterseniz

ğŸ‘‰ Linkledin : https://www.linkedin.com/in/musa-soyda%C5%9F-9097a3212/

